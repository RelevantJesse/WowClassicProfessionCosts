using System.Text;
using WowAhPlanner.Core.Domain;
using WowAhPlanner.Core.Ports;
using Region = WowAhPlanner.Core.Domain.Region;

namespace WowAhPlanner.WinForms.Services;

internal sealed class TargetsService(
    IRecipeRepository recipeRepository,
    IVendorPriceRepository vendorPriceRepository,
    IProducerRepository producerRepository)
{
    public async Task<string> GenerateRecipeTargetsLuaAsync(
        GameVersion gameVersion,
        Region region,
        string realmSlug,
        int professionId,
        bool useCraftIntermediates,
        bool useSmeltIntermediates,
        CancellationToken cancellationToken)
    {
        var professionName = (await recipeRepository.GetProfessionsAsync(gameVersion, cancellationToken))
            .FirstOrDefault(p => p.ProfessionId == professionId)
            ?.Name;

        var recipes = await recipeRepository.GetRecipesAsync(gameVersion, professionId, cancellationToken);
        if (recipes.Count == 0)
        {
            throw new InvalidOperationException($"No recipes found for professionId={professionId} ({gameVersion}).");
        }

        recipes = FilterRecipes(recipes, minSkill: null, maxSkill: null);

        var vendorItemIds = (await vendorPriceRepository.GetVendorPricesAsync(gameVersion, cancellationToken)).Keys.ToHashSet();
        var craftables = useCraftIntermediates
            ? await BuildCraftableProducerIndexAllAsync(gameVersion, cancellationToken)
            : BuildCraftableProducerIndex(recipes);
        var smelt = BuildSmeltProducerIndex(await producerRepository.GetProducersAsync(gameVersion, cancellationToken));

        return GenerateRecipeTargetsLua(
            professionId,
            professionName,
            recipes,
            craftables,
            smelt,
            vendorItemIds,
            useCraftIntermediates,
            useSmeltIntermediates,
            gameVersion,
            region,
            realmSlug);
    }

    private static string EscapeLuaString(string value)
        => value.Replace("\\", "\\\\", StringComparison.Ordinal).Replace("\"", "\\\"", StringComparison.Ordinal);

    private static string GenerateRecipeTargetsLua(
        int professionId,
        string? professionName,
        IReadOnlyList<Recipe> recipes,
        IReadOnlyDictionary<int, Recipe> craftables,
        IReadOnlyDictionary<int, IReadOnlyList<Producer>> smelt,
        IReadOnlySet<int> vendorItemIds,
        bool useCraftIntermediates,
        bool useSmeltIntermediates,
        GameVersion gameVersion,
        Region region,
        string realmSlug)
    {
        var allReagentItemIds = recipes
            .SelectMany(r => r.Reagents)
            .Select(r => r.ItemId)
            .SelectMany(itemId => ExpandScanItemIds(itemId, professionId, craftables, smelt, vendorItemIds, useCraftIntermediates, useSmeltIntermediates))
            .Distinct()
            .OrderBy(x => x)
            .ToArray();

        var ownedItemIds = allReagentItemIds
            .Concat(vendorItemIds)
            .Concat(craftables.Keys)
            .Concat(smelt.Keys)
            .Distinct()
            .OrderBy(x => x)
            .ToArray();

        var lines = new List<string>
        {
            "-- Generated by Profession Leveler",
            $"ProfessionLevelerScan_TargetGameVersion = \"{EscapeLuaString(gameVersion.ToString())}\"",
            $"WowAhPlannerScan_TargetGameVersion = ProfessionLevelerScan_TargetGameVersion",
            $"ProfessionLevelerScan_TargetRegion = \"{EscapeLuaString(region.ToString())}\"",
            $"WowAhPlannerScan_TargetRegion = ProfessionLevelerScan_TargetRegion",
            $"ProfessionLevelerScan_TargetRealmSlug = \"{EscapeLuaString(realmSlug ?? "")}\"",
            $"WowAhPlannerScan_TargetRealmSlug = ProfessionLevelerScan_TargetRealmSlug",
            $"ProfessionLevelerScan_TargetProfessionId = {professionId}",
            $"WowAhPlannerScan_TargetProfessionId = ProfessionLevelerScan_TargetProfessionId",
            $"ProfessionLevelerScan_TargetProfessionName = \"{EscapeLuaString(NormalizeProfessionName(professionName) ?? "")}\"",
            $"WowAhPlannerScan_TargetProfessionName = ProfessionLevelerScan_TargetProfessionName",
            $"ProfessionLevelerScan_VendorItemIds = {{ {string.Join(", ", vendorItemIds.OrderBy(x => x))} }}",
            $"WowAhPlannerScan_VendorItemIds = ProfessionLevelerScan_VendorItemIds",
            $"ProfessionLevelerScan_TargetItemIds = {{ {string.Join(", ", allReagentItemIds)} }}",
            $"WowAhPlannerScan_TargetItemIds = ProfessionLevelerScan_TargetItemIds",
            $"ProfessionLevelerScan_OwnedItemIds = {{ {string.Join(", ", ownedItemIds)} }}",
            $"WowAhPlannerScan_OwnedItemIds = ProfessionLevelerScan_OwnedItemIds",
            "ProfessionLevelerScan_RecipeTargets = {",
        };
        lines.RemoveAll(string.IsNullOrWhiteSpace);

        foreach (var recipe in recipes.OrderBy(r => r.MinSkill).ThenBy(r => r.RecipeId))
        {
            var reagentIds = recipe.Reagents
                .Select(x => x.ItemId)
                .SelectMany(itemId => ExpandScanItemIds(itemId, professionId, craftables, smelt, vendorItemIds, useCraftIntermediates, useSmeltIntermediates))
                .Distinct()
                .OrderBy(x => x)
                .ToArray();

            lines.Add($"  {{ recipeId = \"{EscapeLuaString(recipe.RecipeId)}\", minSkill = {recipe.MinSkill}, grayAt = {recipe.GrayAt}, reagents = {{ {string.Join(", ", reagentIds)} }} }},");
        }

        lines.Add("}");
        lines.Add("WowAhPlannerScan_RecipeTargets = ProfessionLevelerScan_RecipeTargets");
        lines.Add("");
        return string.Join("\r\n", lines);
    }

    private static string? NormalizeProfessionName(string? name)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            return null;
        }

        var trimmed = name.Trim();
        var idx = trimmed.IndexOf('(');
        if (idx > 0)
        {
            trimmed = trimmed[..idx].Trim();
        }

        return trimmed;
    }

    private static IReadOnlyDictionary<int, Recipe> BuildCraftableProducerIndex(IReadOnlyList<Recipe> recipes)
    {
        var byOutput = new Dictionary<int, Recipe>();

        foreach (var recipe in recipes.OrderBy(r => r.MinSkill).ThenBy(r => r.RecipeId, StringComparer.OrdinalIgnoreCase))
        {
            var output = recipe.Output;
            if (output is null) continue;
            if (output.ItemId <= 0) continue;
            if (output.Quantity <= 0) continue;

            if (!byOutput.ContainsKey(output.ItemId))
            {
                byOutput[output.ItemId] = recipe;
            }
        }

        return byOutput;
    }

    private async Task<IReadOnlyDictionary<int, Recipe>> BuildCraftableProducerIndexAllAsync(
        GameVersion version,
        CancellationToken cancellationToken)
    {
        var professions = await recipeRepository.GetProfessionsAsync(version, cancellationToken);
        var all = new List<Recipe>();
        foreach (var prof in professions)
        {
            all.AddRange(await recipeRepository.GetRecipesAsync(version, prof.ProfessionId, cancellationToken));
        }

        var filtered = FilterRecipes(all, minSkill: null, maxSkill: null);
        return BuildCraftableProducerIndex(filtered);
    }

    private static IReadOnlyDictionary<int, IReadOnlyList<Producer>> BuildSmeltProducerIndex(IEnumerable<Producer> producers)
    {
        var byOutput = new Dictionary<int, List<Producer>>();

        foreach (var p in producers.Where(p => p.Kind == ProducerKind.Smelt))
        {
            if (p.Output.ItemId <= 0) continue;
            if (p.Output.Quantity <= 0) continue;

            if (!byOutput.TryGetValue(p.Output.ItemId, out var list))
            {
                list = new List<Producer>();
                byOutput[p.Output.ItemId] = list;
            }

            list.Add(p);
        }

        return byOutput.ToDictionary(kvp => kvp.Key, kvp => (IReadOnlyList<Producer>)kvp.Value.ToArray());
    }

    private static IEnumerable<int> ExpandScanItemIds(
        int itemId,
        int targetProfessionId,
        IReadOnlyDictionary<int, Recipe> craftables,
        IReadOnlyDictionary<int, IReadOnlyList<Producer>> smelt,
        IReadOnlySet<int> vendorItemIds,
        bool useCraftIntermediates,
        bool useSmeltIntermediates)
    {
        var visited = new HashSet<int>();
        var results = new HashSet<int>();
        ExpandScanItemIdsInner(itemId, targetProfessionId, craftables, smelt, vendorItemIds, useCraftIntermediates, useSmeltIntermediates, visited, results);
        return results;
    }

    private static void ExpandScanItemIdsInner(
        int itemId,
        int targetProfessionId,
        IReadOnlyDictionary<int, Recipe> craftables,
        IReadOnlyDictionary<int, IReadOnlyList<Producer>> smelt,
        IReadOnlySet<int> vendorItemIds,
        bool useCraftIntermediates,
        bool useSmeltIntermediates,
        HashSet<int> visited,
        HashSet<int> results)
    {
        if (vendorItemIds.Contains(itemId))
        {
            return;
        }

        if (!visited.Add(itemId))
        {
            results.Add(itemId);
            return;
        }

        try
        {
            if (craftables.TryGetValue(itemId, out var producerRecipe) &&
                (producerRecipe.ProfessionId == targetProfessionId || useCraftIntermediates))
            {
                foreach (var reagent in producerRecipe.Reagents)
                {
                    ExpandScanItemIdsInner(reagent.ItemId, targetProfessionId, craftables, smelt, vendorItemIds, useCraftIntermediates, useSmeltIntermediates, visited, results);
                }
                return;
            }

            if (useSmeltIntermediates && smelt.TryGetValue(itemId, out var producers))
            {
                results.Add(itemId);
                foreach (var producer in producers)
                {
                    foreach (var reagent in producer.Reagents)
                    {
                        ExpandScanItemIdsInner(reagent.ItemId, targetProfessionId, craftables, smelt, vendorItemIds, useCraftIntermediates, useSmeltIntermediates, visited, results);
                    }
                }
                return;
            }

            results.Add(itemId);
        }
        finally
        {
            visited.Remove(itemId);
        }
    }

    private static IReadOnlyList<Recipe> FilterRecipes(IReadOnlyList<Recipe> recipes, int? minSkill, int? maxSkill)
    {
        return recipes
            .Where(r =>
            {
                if (r.OutputQuality is int q && q >= 3) return false;
                if (minSkill is int min && r.GrayAt <= min) return false;
                if (maxSkill is int max && r.MinSkill > max) return false;
                return true;
            })
            .ToArray();
    }
}
